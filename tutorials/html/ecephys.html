
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Neurodata Without Borders: Neurophysiology (NWB:N), Extracellular Electrophysiology Tutorial</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-01-22"><meta name="DC.source" content="ecephys.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Neurodata Without Borders: Neurophysiology (NWB:N), Extracellular Electrophysiology Tutorial</h1><!--introduction--><p>How to write ecephys data to an NWB file using matnwb.</p><pre>author: Ben Dichter
contact: ben.dichter@gmail.com
last edited: Jan 22, 2019</pre><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">NWB file</a></li><li><a href="#3">Data dependencies</a></li><li><a href="#5">Electrode Table</a></li><li><a href="#7">Multielectrode recording</a></li><li><a href="#10">Trials</a></li><li><a href="#12">Spikes</a></li><li><a href="#15">Processing Modules</a></li><li><a href="#18">Writing the file</a></li><li><a href="#19">Reading the file</a></li><li><a href="#20">Reading data</a></li><li><a href="#24">Reading units (RegionViews)</a></li><li><a href="#28">External Links</a></li></ul></div><h2 id="1">NWB file</h2><p>All contents get added to the NWB file, which is created with the following command</p><pre class="codeinput">date = datetime(2018, 3, 1, 12, 0, 0);
session_start_time = datetime(date,<span class="string">'Format'</span>,<span class="string">'yyyy-MM-dd''T''HH:mm:SSZZ'</span>,<span class="keyword">...</span>
    <span class="string">'TimeZone'</span>,<span class="string">'local'</span>);
nwb = nwbfile( <span class="string">'source'</span>, <span class="string">'acquired on rig2'</span>, <span class="keyword">...</span>
    <span class="string">'session_description'</span>, <span class="string">'a test NWB File'</span>, <span class="keyword">...</span>
    <span class="string">'identifier'</span>, <span class="string">'mouse004_day4'</span>, <span class="keyword">...</span>
    <span class="string">'session_start_time'</span>, session_start_time);
</pre><p>You can check the contents by displaying the nwbfile object</p><pre class="codeinput">disp(nwb);
</pre><pre class="codeoutput">  nwbfile with properties:

                                nwb_version: '2.0b'
                                acquisition: [1&times;1 types.untyped.Set]
                                   analysis: [1&times;1 types.untyped.Set]
                           file_create_date: []
                                    general: [1&times;1 types.untyped.Set]
                    general_data_collection: []
                            general_devices: [1&times;1 types.untyped.Set]
             general_experiment_description: []
                       general_experimenter: []
                general_extracellular_ephys: [1&times;1 types.untyped.Set]
     general_extracellular_ephys_electrodes: []
                        general_institution: []
                general_intracellular_ephys: [1&times;1 types.untyped.Set]
      general_intracellular_ephys_filtering: []
    general_intracellular_ephys_sweep_table: []
                           general_keywords: []
                                general_lab: []
                              general_notes: []
                       general_optogenetics: [1&times;1 types.untyped.Set]
                     general_optophysiology: [1&times;1 types.untyped.Set]
                       general_pharmacology: []
                           general_protocol: []
               general_related_publications: []
                         general_session_id: []
                             general_slices: []
                      general_source_script: []
            general_source_script_file_name: []
                     general_specifications: [1&times;1 types.untyped.Set]
                           general_stimulus: []
                            general_subject: []
                            general_surgery: []
                              general_virus: []
                                 identifier: 'mouse004_day4'
                                  intervals: [1&times;1 types.untyped.Set]
                           intervals_epochs: []
                    intervals_invalid_times: []
                           intervals_trials: []
                                 processing: [1&times;1 types.untyped.Set]
                        session_description: 'a test NWB File'
                         session_start_time: 2018-03-01T12:00:00+0200
                      stimulus_presentation: [1&times;1 types.untyped.Set]
                         stimulus_templates: [1&times;1 types.untyped.Set]
                  timestamps_reference_time: []
                                      units: []
                                       help: 'an NWB:N file for storing cellular-based neurophysiology data'

</pre><h2 id="3">Data dependencies</h2><p>The data needs to be added to nwb in a specific order, which is specified by the data dependencies in the schema. The data dependencies for LFP are illustrated in the following diagram. In order to write LFP, you need to specify what electrodes it came from. To do that, you first need to construct an electrode table.</p><p><img vspace="5" hspace="5" src="ecephys_data_deps.png" alt=""> </p><h2 id="5">Electrode Table</h2><p>Electrode tables hold the position and group information about each electrode and the brain region and filtering. Groups organize electrodes within a single device. Devices can have 1 or more groups. In this example, we have 2 devices that each only have a single group.</p><pre class="codeinput">device_labels = {<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'b'</span>,<span class="string">'b'</span>,<span class="string">'b'</span>,<span class="string">'b'</span>};

udevice_labels = unique(device_labels, <span class="string">'stable'</span>);

variables = {<span class="string">'id'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>, <span class="string">'imp'</span>, <span class="string">'location'</span>, <span class="string">'filtering'</span>, <span class="keyword">...</span>
    <span class="string">'group'</span>, <span class="string">'group_name'</span>};
<span class="keyword">for</span> i_device = 1:length(udevice_labels)
    device_label = udevice_labels{i_device};

    nwb.general_devices.set(device_label,<span class="keyword">...</span>
        types.core.Device());

    nwb.general_extracellular_ephys.set(device_label,<span class="keyword">...</span>
        types.core.ElectrodeGroup(<span class="keyword">...</span>
        <span class="string">'description'</span>, <span class="string">'a test ElectrodeGroup'</span>, <span class="keyword">...</span>
        <span class="string">'location'</span>, <span class="string">'unknown'</span>, <span class="keyword">...</span>
        <span class="string">'device'</span>, types.untyped.SoftLink([<span class="string">'/general/devices/'</span> device_label])));

    ov = types.untyped.ObjectView([<span class="string">'/general/extracellular_ephys/'</span> device_label]);

    elec_nums = find(strcmp(device_labels, device_label));
    <span class="keyword">for</span> i_elec = 1:length(elec_nums)
        elec_num = elec_nums(i_elec);
        <span class="keyword">if</span> i_device == 1 &amp;&amp; i_elec == 1
            tbl = table(int64(1), NaN, NaN, NaN, NaN, {<span class="string">'CA1'</span>}, {<span class="string">'filtering'</span>}<span class="keyword">...</span>
                , ov, {<span class="string">'electrode_group'</span>},<span class="string">'VariableNames'</span>, variables);
        <span class="keyword">else</span>
            tbl = [tbl; {int64(elec_num), NaN, NaN, NaN, NaN,<span class="keyword">...</span>
                <span class="string">'CA1'</span>, <span class="string">'filtering'</span>, ov, <span class="string">'electrode_group'</span>}];
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p>add the <tt>DynamicTable</tt> object to the NWB file in /general/extracellular_ephys/electrodes</p><pre class="codeinput">tbl.Properties.Description = <span class="string">'my description'</span>;

electrode_table = util.table2nwb(tbl);
nwb.general_extracellular_ephys_electrodes = electrode_table;
</pre><h2 id="7">Multielectrode recording</h2><p>In order to write a multielectrode recording, you need to construct a region view of the electrode table to link the signal to the electrodes that generated them. You must do this even if the signal is from all of the electrodes. Here we will create a reference that includes all electrodes. Then we will generate a signal 1000 timepoints long from 10 channels.</p><pre class="codeinput">ov = types.untyped.ObjectView(<span class="string">'/general/extracellular_ephys/electrodes'</span>);

electrode_table_region = types.core.DynamicTableRegion(<span class="string">'table'</span>, ov, <span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'all electrodes'</span>,<span class="keyword">...</span>
    <span class="string">'data'</span>, [1 height(tbl)]');
</pre><p>once you have the <tt>ElectrodeTableRegion</tt> object, you can create an <tt>ElectricalSeries</tt> object to hold your multielectrode data. An <tt>ElectricalSeries</tt> is an example of a <tt>TimeSeries</tt> object. For all <tt>TimeSeries</tt> objects, you have 2 options for storing time information. The first is to use <tt>starting_time</tt> and <tt>rate</tt>:</p><pre class="codeinput"><span class="comment">% generate data for demonstration</span>
data = reshape(1:10000, 10, 1000);

electrical_series = types.core.ElectricalSeries(<span class="keyword">...</span>
    <span class="string">'starting_time'</span>, 0.0, <span class="keyword">...</span><span class="comment"> % seconds</span>
    <span class="string">'starting_time_rate'</span>, 200., <span class="keyword">...</span><span class="comment"> % Hz</span>
    <span class="string">'data'</span>, data,<span class="keyword">...</span>
    <span class="string">'electrodes'</span>, electrode_table_region,<span class="keyword">...</span>
    <span class="string">'data_unit'</span>,<span class="string">'V'</span>);

nwb.acquisition.set(<span class="string">'ECoG'</span>, electrical_series);
</pre><p>You can also specify time using <tt>timestamps</tt>. This is particularly useful if the sample times are not evenly sampled. In this case, the electrical series constructor will look like this</p><pre class="codeinput">electrical_series = types.core.ElectricalSeries(<span class="keyword">...</span>
    <span class="string">'timestamps'</span>, (1:1000)/200, <span class="keyword">...</span>
    <span class="string">'data'</span>, data,<span class="keyword">...</span>
    <span class="string">'electrodes'</span>, electrode_table_region,<span class="keyword">...</span>
    <span class="string">'data_unit'</span>,<span class="string">'V'</span>);
</pre><h2 id="10">Trials</h2><p>You can store trial information in the trials table</p><pre class="codeinput">trials = types.core.TimeIntervals( <span class="keyword">...</span>
    <span class="string">'colnames'</span>, {<span class="string">'correct'</span>,<span class="string">'start_time'</span>,<span class="string">'stop_time'</span>},<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'trial data and properties'</span>, <span class="keyword">...</span>
    <span class="string">'id'</span>, types.core.ElementIdentifiers(<span class="string">'data'</span>, 0:2),<span class="keyword">...</span>
    <span class="string">'start_time'</span>, types.core.VectorData(<span class="string">'data'</span>, [.1, 1.5, 2.5],<span class="keyword">...</span>
        <span class="string">'description'</span>,<span class="string">'start time of trial'</span>),<span class="keyword">...</span>
    <span class="string">'stop_time'</span>, types.core.VectorData(<span class="string">'data'</span>, [1., 2., 3.],<span class="keyword">...</span>
        <span class="string">'description'</span>,<span class="string">'end of each trial'</span>),<span class="keyword">...</span>
    <span class="string">'correct'</span>, types.core.VectorData(<span class="string">'data'</span>, [false,true,false],<span class="keyword">...</span>
        <span class="string">'description'</span>,<span class="string">'my description'</span>));

nwb.intervals_trials = trials;
</pre><p><tt>colnames</tt> is flexible - it can store any column names and the entries can be any data type, which allows you to store any information you need about trials.</p><h2 id="12">Spikes</h2><p>Spikes are stored in the <tt>units</tt> table, which uses 3 arrays to store the spike times of all the cells.</p><p><img vspace="5" hspace="5" src="UnitTimes.png" alt=""> </p><p>to add spike data to the units table</p><pre class="codeinput">spike_times = [0.1, 0.21, 0.34, 0.36, 0.4, 0.43, 0.5, 0.61, 0.66, 0.69];
unit_ids = [0, 0, 1, 1, 2, 2, 0, 0, 1, 1];

[spike_times_vector, spike_times_index] = util.create_spike_times(unit_ids, spike_times);
nwb.units = types.core.Units(<span class="string">'colnames'</span>, {<span class="string">'spike_times'</span>, <span class="string">'spike_times_index'</span>},<span class="keyword">...</span>
    <span class="string">'description'</span>,<span class="string">'units table'</span>,<span class="keyword">...</span>
    <span class="string">'id'</span>, types.core.ElementIdentifiers(<span class="string">'data'</span>, 0:length(spike_times_index.data) - 1));
nwb.units.spike_times = spike_times_vector;
nwb.units.spike_times_index = spike_times_index;
</pre><h2 id="15">Processing Modules</h2><p>Measurements go in <tt>acquisition</tt> and subject or session data goes in <tt>general</tt>, but if you have the intermediate processing results, you should put them in a processing module.</p><pre class="codeinput">ecephys_mod = types.core.ProcessingModule(<span class="string">'description'</span>, <span class="string">'contains clustering data'</span>);
</pre><p>The <tt>Clustering</tt> data structure holds information about the spike-sorting process.</p><pre class="codeinput">clustering = types.core.Clustering( <span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'my_description'</span>,<span class="keyword">...</span>
    <span class="string">'peak_over_rms'</span>, [1, 2, 3],<span class="keyword">...</span>
    <span class="string">'times'</span>, spike_times, <span class="keyword">...</span>
    <span class="string">'num'</span>, cluster_ids);

cell_mod.nwbdatainterface.set(<span class="string">'clustering'</span>, clustering);
</pre><p>I am going to call this processing module "ecephys." As a convention, I use the names of the NWB core namespace modules as the names of my processing modules, however this is not a rule and you may use any name.</p><pre class="codeinput">nwb.processing.set(<span class="string">'ecephys'</span>, ecephys_mod);
</pre><h2 id="18">Writing the file</h2><p>Once you have added all of the data types you want to a file, you can save it with the following command</p><pre class="codeinput">nwbExport(nwb, <span class="string">'ecephys_tutorial.nwb'</span>)
</pre><pre class="codeoutput">Warning: Overwriting
ecephys_tutorial.nwb 
</pre><h2 id="19">Reading the file</h2><p>load an NWB file object with</p><pre class="codeinput">nwb2 = nwbRead(<span class="string">'ecephys_tutorial.nwb'</span>);
</pre><h2 id="20">Reading data</h2><p>Note that <tt>nwbRead</tt> does <b>not</b> load all of the dataset contained within the file. matnwb automatically supports "lazy read" which means you only read data to memory when you need it, and only read the data you need. Notice the command</p><pre class="codeinput">disp(nwb2.acquisition.get(<span class="string">'ECoG'</span>).data)
</pre><pre class="codeoutput">  DataStub with properties:

    filename: 'ecephys_tutorial.nwb'
        path: '/acquisition/ECoG/data'
        dims: [1000 10]

</pre><p>returns a DataStub object and does not output the values contained in <tt>data</tt>. To get these values, run</p><pre class="codeinput">data = nwb2.acquisition.get(<span class="string">'ECoG'</span>).data.load;
disp(data(1:10, 1:10));
</pre><pre class="codeoutput">     1    11    21    31    41    51    61    71    81    91
     2    12    22    32    42    52    62    72    82    92
     3    13    23    33    43    53    63    73    83    93
     4    14    24    34    44    54    64    74    84    94
     5    15    25    35    45    55    65    75    85    95
     6    16    26    36    46    56    66    76    86    96
     7    17    27    37    47    57    67    77    87    97
     8    18    28    38    48    58    68    78    88    98
     9    19    29    39    49    59    69    79    89    99
    10    20    30    40    50    60    70    80    90   100

</pre><p>Loading all of the data can be a problem when dealing with real data that can be several GBs or even TBs per session. In these cases you can load a specific section of data. For instance, here is how you would load data starting at the index (1,1) and read 10 rows and 20 columns of data</p><pre class="codeinput">nwb2.acquisition.get(<span class="string">'ECoG'</span>).data.load([1,1], [10,20])
</pre><pre class="codeoutput">
ans =

  Columns 1 through 13

     1    11    21    31    41    51    61    71    81    91   101   111   121
     2    12    22    32    42    52    62    72    82    92   102   112   122
     3    13    23    33    43    53    63    73    83    93   103   113   123
     4    14    24    34    44    54    64    74    84    94   104   114   124
     5    15    25    35    45    55    65    75    85    95   105   115   125
     6    16    26    36    46    56    66    76    86    96   106   116   126
     7    17    27    37    47    57    67    77    87    97   107   117   127
     8    18    28    38    48    58    68    78    88    98   108   118   128
     9    19    29    39    49    59    69    79    89    99   109   119   129
    10    20    30    40    50    60    70    80    90   100   110   120   130

  Columns 14 through 20

   131   141   151   161   171   181   191
   132   142   152   162   172   182   192
   133   143   153   163   173   183   193
   134   144   154   164   174   184   194
   135   145   155   165   175   185   195
   136   146   156   166   176   186   196
   137   147   157   167   177   187   197
   138   148   158   168   178   188   198
   139   149   159   169   179   189   199
   140   150   160   170   180   190   200

</pre><p>run <tt>doc('types.untyped.DataStub')</tt> for more details on manual partial loading. There are several convenience functions that make common data loading patterns easier. The following convenience function loads data for all trials</p><pre class="codeinput"><span class="comment">% data from .05 seconds before and half a second after start of each trial</span>
window = [-.05, 0.5]; <span class="comment">% seconds</span>

<span class="comment">% only data where the attribute 'correct' == 0</span>
conditions = containers.Map(<span class="string">'correct'</span>, 0);

<span class="comment">% get ECoG data</span>
timeseries = nwb2.acquisition.get(<span class="string">'ECoG'</span>);

[trial_data, tt] = util.loadTrialAlignedTimeSeriesData(nwb2, <span class="keyword">...</span>
    timeseries, window, conditions);

<span class="comment">% plot data from the first electrode for those two trials</span>
plot(tt, squeeze(trial_data(:,1,:)))
xlabel(<span class="string">'time (seconds)'</span>)
ylabel([<span class="string">'ECoG ('</span> timeseries.data_unit <span class="string">')'</span>])
</pre><img vspace="5" hspace="5" src="ecephys_01.png" alt=""> <h2 id="24">Reading units (RegionViews)</h2><p>The <tt>units</tt> table uses an index array to indicate which spikes belong to which cell. The structure is split up into 3 datasets (see Spikes secion):</p><pre class="codeinput">my_spike_times = nwb.units.spike_times;
</pre><p>To get the data for cell 1, first determine the uid that equals 1.</p><pre class="codeinput">select = nwb.units.id.data == 1
</pre><pre class="codeoutput">
select =

  1&times;3 logical array

   0   1   0

</pre><p>Then select the corresponding spike_times_index element</p><pre class="codeinput">my_index = nwb.units.spike_times_index.data(select)
</pre><pre class="codeoutput">
my_index = 

  RegionView with properties:

      path: '/units/spike_times'
      view: [1&times;1 types.untyped.ObjectView]
    region: {[2&times;1 double]}

</pre><p>Finally, access the data that the view points to using <tt>refresh</tt></p><pre class="codeinput">my_index.refresh(nwb)
</pre><pre class="codeoutput">
ans =

    0.3400    0.3600    0.6600    0.6900

</pre><h2 id="28">External Links</h2><p>NWB allows you to link to datasets within another file through HDF5 <tt>ExternalLink|s. This is useful for separating out large datasets that are not always needed. It also allows you to store data once, and access it across many NWB files, so it is useful for storing subject-related data that is the same for all sessions. Here is an example of creating a link from the Subject object from the |ecephys_tutorial.nwb</tt> file we just created in a new file.</p><pre class="codeinput">nwb3 = nwbfile(<span class="string">'session_description'</span>, <span class="string">'a test NWB File'</span>, <span class="keyword">...</span>
    <span class="string">'identifier'</span>, <span class="string">'mouse004_day4'</span>, <span class="keyword">...</span>
    <span class="string">'session_start_time'</span>, session_start_time);
nwb3.general_subject = types.untyped.ExternalLink(<span class="string">'ecephys_tutorial.nwb'</span>,<span class="keyword">...</span>
    <span class="string">'/general/subject'</span>);

nwbExport(nwb3, <span class="string">'link_test.nwb'</span>)
</pre><pre class="codeoutput">Warning: Overwriting
link_test.nwb 
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Neurodata Without Borders: Neurophysiology (NWB:N), Extracellular Electrophysiology Tutorial
% How to write ecephys data to an NWB file using matnwb.
% 
%  author: Ben Dichter
%  contact: ben.dichter@gmail.com
%  last edited: Jan 22, 2019

%% NWB file
% All contents get added to the NWB file, which is created with the
% following command

date = datetime(2018, 3, 1, 12, 0, 0);
session_start_time = datetime(date,'Format','yyyy-MM-dd''T''HH:mm:SSZZ',...
    'TimeZone','local');
nwb = nwbfile( 'source', 'acquired on rig2', ...
    'session_description', 'a test NWB File', ...
    'identifier', 'mouse004_day4', ...
    'session_start_time', session_start_time);

%%
% You can check the contents by displaying the nwbfile object
disp(nwb);

%% Data dependencies
% The data needs to be added to nwb in a specific order, which is specified
% by the data dependencies in the schema. The data dependencies for LFP are
% illustrated in the following diagram. In order to write LFP, you need to 
% specify what electrodes it came from. To do that, you first need to 
% construct an electrode table. 
%%
% 
% <<ecephys_data_deps.png>>
% 

%% Electrode Table
% Electrode tables hold the position and group information about each 
% electrode and the brain region and filtering. Groups organize electrodes 
% within a single device. Devices can have 1 or more groups. In this example, 
% we have 2 devices that each only have a single group.

device_labels = {'a','a','a','a','a','b','b','b','b','b'};

udevice_labels = unique(device_labels, 'stable');

variables = {'id', 'x', 'y', 'z', 'imp', 'location', 'filtering', ...
    'group', 'group_name'};
for i_device = 1:length(udevice_labels)
    device_label = udevice_labels{i_device};
    
    nwb.general_devices.set(device_label,...
        types.core.Device());
    
    nwb.general_extracellular_ephys.set(device_label,...
        types.core.ElectrodeGroup(...
        'description', 'a test ElectrodeGroup', ...
        'location', 'unknown', ...
        'device', types.untyped.SoftLink(['/general/devices/' device_label])));
    
    ov = types.untyped.ObjectView(['/general/extracellular_ephys/' device_label]);
    
    elec_nums = find(strcmp(device_labels, device_label));
    for i_elec = 1:length(elec_nums)
        elec_num = elec_nums(i_elec);
        if i_device == 1 && i_elec == 1
            tbl = table(int64(1), NaN, NaN, NaN, NaN, {'CA1'}, {'filtering'}...
                , ov, {'electrode_group'},'VariableNames', variables);
        else
            tbl = [tbl; {int64(elec_num), NaN, NaN, NaN, NaN,...
                'CA1', 'filtering', ov, 'electrode_group'}];
        end
    end        
end
%%
% add the |DynamicTable| object to the NWB file in
% /general/extracellular_ephys/electrodes

tbl.Properties.Description = 'my description';

electrode_table = util.table2nwb(tbl);
nwb.general_extracellular_ephys_electrodes = electrode_table;

%% Multielectrode recording
% In order to write a multielectrode recording, you need to construct a 
% region view of the electrode table to link the signal to the electrodes 
% that generated them. You must do this even if the signal is from all of 
% the electrodes. Here we will create a reference that includes all 
% electrodes. Then we will generate a signal 1000 timepoints long from 10 
% channels.

ov = types.untyped.ObjectView('/general/extracellular_ephys/electrodes');

electrode_table_region = types.core.DynamicTableRegion('table', ov, ...
    'description', 'all electrodes',...
    'data', [1 height(tbl)]');

%%
% once you have the |ElectrodeTableRegion| object, you can create an
% |ElectricalSeries| object to hold your multielectrode data. An 
% |ElectricalSeries| is an example of a |TimeSeries| object. For all 
% |TimeSeries| objects, you have 2 options for storing time information.
% The first is to use |starting_time| and |rate|:

% generate data for demonstration
data = reshape(1:10000, 10, 1000);

electrical_series = types.core.ElectricalSeries(...
    'starting_time', 0.0, ... % seconds
    'starting_time_rate', 200., ... % Hz
    'data', data,...
    'electrodes', electrode_table_region,...
    'data_unit','V');

nwb.acquisition.set('ECoG', electrical_series);
%%
% You can also specify time using |timestamps|. This is particularly useful if
% the sample times are not evenly sampled. In this case, the electrical series
% constructor will look like this

electrical_series = types.core.ElectricalSeries(...
    'timestamps', (1:1000)/200, ...
    'data', data,...
    'electrodes', electrode_table_region,...
    'data_unit','V');

%% Trials
% You can store trial information in the trials table

trials = types.core.TimeIntervals( ...
    'colnames', {'correct','start_time','stop_time'},...
    'description', 'trial data and properties', ...
    'id', types.core.ElementIdentifiers('data', 0:2),...
    'start_time', types.core.VectorData('data', [.1, 1.5, 2.5],...
        'description','start time of trial'),...
    'stop_time', types.core.VectorData('data', [1., 2., 3.],...
        'description','end of each trial'),...
    'correct', types.core.VectorData('data', [false,true,false],...
        'description','my description'));

nwb.intervals_trials = trials;

%%
% |colnames| is flexible - it can store any column names and the entries can
% be any data type, which allows you to store any information you need about 
% trials.

%% Spikes
% Spikes are stored in the |units| table, which uses 3 arrays to store the
% spike times of all the cells.

%%
% 
% <<UnitTimes.png>>
% 
%%
% to add spike data to the units table

spike_times = [0.1, 0.21, 0.34, 0.36, 0.4, 0.43, 0.5, 0.61, 0.66, 0.69];
unit_ids = [0, 0, 1, 1, 2, 2, 0, 0, 1, 1];

[spike_times_vector, spike_times_index] = util.create_spike_times(unit_ids, spike_times);
nwb.units = types.core.Units('colnames', {'spike_times', 'spike_times_index'},...
    'description','units table',...
    'id', types.core.ElementIdentifiers('data', 0:length(spike_times_index.data) - 1));
nwb.units.spike_times = spike_times_vector;
nwb.units.spike_times_index = spike_times_index;

%% Processing Modules
% Measurements go in |acquisition| and subject or session data goes in
% |general|, but if you have the intermediate processing results, you
% should put them in a processing module.

ecephys_mod = types.core.ProcessingModule('description', 'contains clustering data');

%%
% The |Clustering| data structure holds information about the spike-sorting
% process.

clustering = types.core.Clustering( ...
    'description', 'my_description',...
    'peak_over_rms', [1, 2, 3],...
    'times', spike_times, ...
    'num', cluster_ids);

cell_mod.nwbdatainterface.set('clustering', clustering);

%%
% I am going to call this processing module "ecephys." As a convention, I 
% use the names of the NWB core namespace modules as the names of my 
% processing modules, however this is not a rule and you may use any name.

nwb.processing.set('ecephys', ecephys_mod);

%% Writing the file
% Once you have added all of the data types you want to a file, you can save
% it with the following command

nwbExport(nwb, 'ecephys_tutorial.nwb')

%% Reading the file
% load an NWB file object with

nwb2 = nwbRead('ecephys_tutorial.nwb');

%% Reading data
% Note that |nwbRead| does *not* load all of the dataset contained 
% within the file. matnwb automatically supports "lazy read" which means
% you only read data to memory when you need it, and only read the data you
% need. Notice the command

disp(nwb2.acquisition.get('ECoG').data)

%%
% returns a DataStub object and does not output the values contained in 
% |data|. To get these values, run

data = nwb2.acquisition.get('ECoG').data.load;
disp(data(1:10, 1:10));

%%
% Loading all of the data can be a problem when dealing with real data that can be
% several GBs or even TBs per session. In these cases you can load a specific section of
% data. For instance, here is how you would load data starting at the index
% (1,1) and read 10 rows and 20 columns of data

nwb2.acquisition.get('ECoG').data.load([1,1], [10,20])

%%
% run |doc('types.untyped.DataStub')| for more details on manual partial
% loading. There are several convenience functions that make common data
% loading patterns easier. The following convenience function loads data 
% for all trials

% data from .05 seconds before and half a second after start of each trial
window = [-.05, 0.5]; % seconds

% only data where the attribute 'correct' == 0
conditions = containers.Map('correct', 0);

% get ECoG data
timeseries = nwb2.acquisition.get('ECoG');

[trial_data, tt] = util.loadTrialAlignedTimeSeriesData(nwb2, ...
    timeseries, window, conditions);

% plot data from the first electrode for those two trials
plot(tt, squeeze(trial_data(:,1,:)))
xlabel('time (seconds)')
ylabel(['ECoG (' timeseries.data_unit ')'])

%% Reading units (RegionViews)
% The |units| table uses an index array to indicate which spikes belong to which cell.
% The structure is split up into 3 datasets (see Spikes secion):
my_spike_times = nwb.units.spike_times;
%%
% To get the data for cell 1, first determine the uid that equals 1.
select = nwb.units.id.data == 1
%%
% Then select the corresponding spike_times_index element
my_index = nwb.units.spike_times_index.data(select)
%%
% Finally, access the data that the view points to using |refresh|
my_index.refresh(nwb)

%% External Links
% NWB allows you to link to datasets within another file through HDF5
% |ExternalLink|s. This is useful for separating out large datasets that are
% not always needed. It also allows you to store data once, and access it 
% across many NWB files, so it is useful for storing subject-related
% data that is the same for all sessions. Here is an example of creating a
% link from the Subject object from the |ecephys_tutorial.nwb| file we just
% created in a new file.
 
nwb3 = nwbfile('session_description', 'a test NWB File', ...
    'identifier', 'mouse004_day4', ...
    'session_start_time', session_start_time);
nwb3.general_subject = types.untyped.ExternalLink('ecephys_tutorial.nwb',...
    '/general/subject');
 
nwbExport(nwb3, 'link_test.nwb')

##### SOURCE END #####
--></body></html>